
export class CancellationToken {
  static MAX_NUMBER_OF_WORKERS = 32;

  private static shared: ArrayBuffer = crossOriginIsolated? new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * this.MAX_NUMBER_OF_WORKERS): new ArrayBuffer(0);
  private static array: Int32Array = new Int32Array(this.shared);
  private static allocatedTokens = 0;

  private tokenIndex: number;

  private constructor(offset: number) {
    this.tokenIndex = offset;
  }

  static register(): CancellationToken {
    const index = this.findIndex(this.allocatedTokens, (index: number) => !Atomics.load(this.array, index));
    if(index === -1 && crossOriginIsolated && this.buffer instanceof SharedArrayBuffer) {
      throw new Error('Number of simultaneously used cancellation tokens exceeded the admissible limit');
    } else if (CancellationToken.withinArray(index)){
      Atomics.store(CancellationToken.array, index, 2);
      this.allocatedTokens++;
    }
    return new CancellationToken(index);
  }

  release() {
    if (CancellationToken.withinArray(this.tokenIndex)) {
      Atomics.store(CancellationToken.array, this.tokenIndex, 0);
    }
  }

  cancel(): void {
    if (CancellationToken.withinArray(this.tokenIndex)) {
      Atomics.store(CancellationToken.array, this.tokenIndex, 1);
    }
  }

  reset(): void {
    if (CancellationToken.withinArray(this.tokenIndex)) {
      Atomics.store(CancellationToken.array, this.tokenIndex, 2);
    }
  }

  get cancelled(): boolean {
    return CancellationToken.withinArray(this.tokenIndex) && Atomics.load(CancellationToken.array, this.tokenIndex) === 1;
  }

  get index(): number {
    return this.tokenIndex
  }

  static get buffer(): ArrayBuffer {
    return CancellationToken.shared;
  }

  private static withinArray(index: number): boolean {
    return index > -1 && this.MAX_NUMBER_OF_WORKERS > index;
  }

  private static findIndex(start: number, predicate: Function): number {
    const arrayLength = this.buffer.byteLength / Int32Array.BYTES_PER_ELEMENT;
    let unchecked = arrayLength;
    while(unchecked !== 0) {
      if(start >= arrayLength) { start %= arrayLength; }
      if(predicate(start)) { return start; }
      else { start++; unchecked--; }
    }

    return -1;
  }
}



export interface WorkerHelpers {
  cancelled: Function;
  next: Function;
  progress: Function;
  done: Function;
  error: Function;
}

export type WorkerResult = any;

export type WorkerMethod = (data: any, helpers: WorkerHelpers | any) => WorkerResult | Promise<WorkerResult>;

export class InlineWorker {
  private cancellationToken: CancellationToken | null;
  private workerbody: string;
  private worker: Worker | null;
  private onprogress: ((data: number) => void);
  private onnext: ((data: any) => void);
  private injected: string[];
  private promise: Promise<any> | null;
  private resolve: (args: any) => void;
  private reject: (args: any) => void;

  constructor(task: WorkerMethod) {

    if (!isWorkerSupported()) {
      throw new Error('Web Worker is not supported');
    }

    let funcbody = task.toString()

    if(isWebpackBundlerPresent()) {
      // get rid of indirect function calls generated by WEBPACK
      funcbody = funcbody.replace(/\((?:.*,)(?:.*WEBPACK_IMPORTED_MODULE.*\.)(.*)\)(\(.*\))/g, "$1$2");
    }

    this.workerbody = `self.onmessage=function(event){let __wcb__=new Int32Array(event.data.cancellationBuffer),__wti__=event.data.tokenIndex,__wc__=()=>__wti__>-1&&1===Atomics.load(__wcb__,__wti__),__wp__=new Promise((__wr__,__wrj__)=>{let __wrd__=!1,__wrjd__=!1,__wrst__=(${funcbody})(event.data.data,{cancelled:__wc__,next(e){self.postMessage({type:"next",value:e})},progress(e){self.postMessage({type:"progress",value:e})},done(e){__wrd__=!0,__wr__(e)},error(e){__wrjd__=!0,__wrj__(e)}});if(__wrst__ instanceof Promise)return __wrst__.then(__wr__,__wrj__);if(!__wrd__&&!__wrjd__&&void 0!==__wrst__)return __wr__(__wrst__),__wrst__;if(__wc__()){__wr__(void 0);return}}).then(e=>{__wc__()?self.postMessage({type:"cancelled",value:void 0}):self.postMessage({type:"done",value:e})}).catch(e=>self.postMessage({type:"error",error:e}))};`;
    this.cancellationToken = this.promise = null; this.resolve = () => {}; this.reject = () => {};
    this.worker = null; this.injected  = []; this.onprogress = this.onnext = () => {};
  }

  static terminate(workers: InlineWorker[]): void {
    workers.forEach(worker => worker.worker?.terminate());
  }

  cancel(): void {
    if(this.running()) {
      this.cancellationToken?.cancel();
    }
  }

  terminate(): void {
    if(this.running()) {
      this.worker?.terminate();
      this.promise = null;
      this.resolve(undefined);
      this.cancellationToken?.release();
    }
  }

  run(data?: any, transferList?: Transferable[]): Promise<any> {
    if(!this.promise) {
      this.cancellationToken = CancellationToken.register();
      let blob = new Blob([this.workerbody].concat(this.injected), { type: 'application/javascript' });
      this.worker = new Worker(URL.createObjectURL(blob));
      this.worker.postMessage({ data: data, cancellationBuffer: CancellationToken.buffer, tokenIndex: this.cancellationToken.index}, transferList as any);
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve; this.reject = reject;
        this.worker!.onmessage = (e: MessageEvent) => {
          if (e.data?.type === 'done') { this.promise = null; resolve(e.data.value); this.cancellationToken?.release(); }
          else if (e.data?.type === 'progress') { this.onprogress && this.onprogress(e.data.value); }
          else if (e.data?.type === 'next') { this.onnext && this.onnext(e.data.value); }
          else if (e.data?.type === 'cancelled') { this.promise = null; resolve(undefined); this.cancellationToken?.release(); }
          else if (e.data?.type === 'error') { this.promise = null; reject(e.data.error); this.cancellationToken?.release(); }
        }
      });
    }

    return this.promise;
  }

  running() {
    return !!this.promise;
  }

  progress(fn: (data: any) => void): InlineWorker {
    this.onprogress = fn;
    return this;
  }

  subscribe(fn: (data: any) => void): InlineWorker {
    this.onnext = fn;
    return this;
  }

  inject(...args: Function[]): InlineWorker {
    this.injected = this.injected ?? []
    for (let i = 0; i < args.length; i++) {
      let fn: Function = args[i];
      if (typeof fn === 'function') {
        let fnBody = fn.toString();
        // check if function is anonymous and name it
        fnBody = fnBody.replace(/function[\s]*\(/, `function ${fn.name}(`);

        if(this.injected.indexOf(fnBody) === -1) {
          this.injected.push(fnBody);
        }
      }
    }
    return this;
  }
}


export function isWorkerSupported(): boolean {
  return !!Worker;
}

export function isWebpackBundlerPresent(): boolean {
  return !!(window as any)["webpackChunkapp2"]
}

export function isCancellationSupported(): boolean {
  return crossOriginIsolated;
}


if(!isCancellationSupported()) {
  console.warn("CancellationToken is not supported in this environment. Please add following two headers to the top level document: 'Cross-Origin-Embedder-Policy': 'require-corp'; 'Cross-Origin-Opener-Policy': 'same-origin';");
}
